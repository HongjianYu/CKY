from typing import Dict, List, Tuple
import string
import copy
def cky(words: List[str], grammar: Dict[str, List]):
    """
    The CKY algorithm finds all possible parses of an ambiguous sentence or phrase generated by a CFG.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar: grammar + lexicon (eg. grammar: NP -> Det N; lexicon: N -> meals)
    """

    # init the 2d table with all elements as {}(empty set), the element type considered
    table = [[set() for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # feed non-terminals into table from terminals in words
        for g in grammar:
            if words[j] in grammar[g]: # find lexicon in grammar
                table[j-1][j].add(g)

        for i in range(j-2, -1, -1):
            for k in range(i+1, j):
                for b in table[i][k]:
                    for c in table[k][j]:
                        bc = str(b + ' ' + c) # eg. "Det N"
                        for g in grammar:
                            if bc in grammar[g]:
                                table[i][j].add(g)

    return table



def senstence_to_words(sentence: str) -> List:
    """
    convert a sentence to a list of words
    the first element in words doesn't contain info about sentence
    (can be optimized)
    """
    words = [0] # the first element doesn't contain any word

    word = ""
    for s in sentence:
        if s != ' ' and s not in string.punctuation: word += s
        else:
            if word != "": words.append(word)
            word = ""

    return words


def pcky(words: List[str], grammar: Dict[Tuple[str, str], float]):
    """
    Ney's variant of the CKY algorithm finds a most probable parse for a phrase or sentence
    in the language generated by an ambiguous Probabilistic Context-Free Grammar.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar: grammar + lexicon (with probability) (eg. grammar: (NP, Det N) -> float; lexicon: (N, meals) -> float)
    """
    # init the 2d table with all elements as {}(dict), the element type considered
    # each element in the table is a (non-terminal: probability)
    table = [[dict() for j in range(len(words))] for i in range(len(words) - 1)]

    # for building the parsing tree
    back = [[set() for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # init
        for g in grammar: # g is a tuple of rules or productions, eg. (NP, Det, N) or (N, meals)
            if words[j] == g[1]:
                table[j-1][j][g[0]] = grammar[g] # probability

        for i in range(j-2, -1, -1):
            for k in range(i+1, j):
                for b in table[i][k]:
                    for c in table[k][j]:
                        prob_b = table[i][k][b]
                        prob_c = table[k][j][c]
                        if prob_b <= 0 or prob_c <= 0: break
                        for g in grammar:
                            if g[1] == str(b + " " + c):
                                if table[i][j].get(g[0]) is None or table[i][j].get(g[0]) < grammar[g] * prob_b * prob_c:
                                    table[i][j][g[0]] = grammar[g] * prob_b * prob_c
                                    back[i][j][g[0]] = {k, b, c}

    return table[1][len(words)-1]

def print_table(table: List[List]):
    for i in range(len(table)):
        for j in range(1, len(table[i])):
            print(table[i][j], end=' ')
        print()

# the parsing tree
class Node:
    def __init__(self, non_terminal, i, j):
        self.non_terminal = non_terminal
        self.pos = (i, j)
        self.children = [] # list of Tuple[left, right]

    def add(self, child):
        self.children.append(child)

    def __str__(self):
        out = f"{self.non_terminal}"
        for i in range(len(self.children)):
            out += f" branch{i + 1}: "
            out += f"{self.children[i][0]}"
            out += f"{self.children[i][1]}"
        return f"[{out}]"

def parse_table(table: List[List], grammar: Dict[str, List]):
    """
    table from cky
    """
    roots = []
    # start symbols (root)
    for s in table[0][len(table[0]) - 1]:
        roots.append(Node(s, 0, len(table[0])-1))
        parsing(roots[-1], table, grammar)

    return roots

def parsing(root: Node, table: List[List], grammar: Dict[str, List]):
    for k in range(root.pos[0]+1, root.pos[1]):
        L = table[root.pos[0]][k]
        R = table[k][root.pos[1]]

        for l in L:
            for r in R:
                if str(l + " " + r) in grammar[root.non_terminal]:
                    root.add((Node(l, root.pos[0], k), Node(r, k, root.pos[1])))
                    parsing(root.children[-1][0], table, grammar)
                    parsing(root.children[-1][1], table, grammar)


def main():
    grammar = { "S": ["A B", "B C"],
                "A": ["B A", "a"],
                "B": ["C C", "b"],
                "C": ["A B", "a"]}

    words = [0, 'b', 'a', 'a', 'b', 'a']

    print_table(cky(words, grammar))
    roots = parse_table(cky(words, grammar), grammar)
    for root in roots:
        print(root)

if __name__ == "__main__":
    main()

