from typing import Dict, List, Tuple
import string


def cky(words: List[str], grammar: Dict[str, List]):
    """
    The CKY algorithm finds all possible parses of an ambiguous sentence or phrase generated by a CFG.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar eg. NP -> Det N; N -> meals
    """
    # init the 2d table with all elements as {}(empty set), the element type considered
    table = [[set() for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # feed non-terminals into table from terminals in words
        for g in grammar:
            if words[j].lower() in grammar[g]:  # find lexical entries in grammar
                table[j - 1][j].add(g)

        for i in range(j - 2, -1, -1):
            for k in range(i + 1, j):
                for b in table[i][k]:
                    for c in table[k][j]:
                        bc = b + " " + c  # eg. "Det N"
                        for g in grammar:
                            if bc in grammar[g]:
                                table[i][j].add(g)

    return table


def pcky(words: List[str], grammar: Dict[str, Dict[str, float]]):
    """
    Ney's variant of the CKY algorithm finds a most probable parse for a phrase or sentence
    in the language generated by an ambiguous Probabilistic Context-Free Grammar.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar eg. NP -> (Det N, 0.2); N -> (meals, 0.3)
    """
    # init the 2d table with all elements as {}(dict), the element type considered
    # each element in the table is a (non-terminal: probability)
    table = [[dict() for j in range(len(words))] for i in range(len(words) - 1)]

    back = [[dict() for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # init
        for g in grammar:  # g is a tuple of rules or productions, eg. (NP, Det, N) or (N, meals)
            if words[j].lower() in grammar[g].keys():
                table[j - 1][j][g] = grammar[g][words[j].lower()]  # probability

        for i in range(j - 2, -1, -1):
            for k in range(i + 1, j):
                for b in table[i][k]:
                    for c in table[k][j]:
                        p_b, p_c = table[i][k][b], table[k][j][c]
                        if p_b > 0.0 and p_c > 0.0:
                            for g in grammar:
                                bc = b + " " + c
                                if bc in grammar[g].keys():
                                    if table[i][j].get(g) is None or table[i][j].get(g) < grammar[g][bc] * p_b * p_c:
                                        table[i][j][g] = grammar[g][bc] * p_b * p_c
                                        back[i][j][g] = (k, b, c)

    # return table[1][len(words) - 1]
    return table


def print_table(table: List[List]):
    for i in range(len(table)):
        for j in range(1, len(table[i])):
            print(table[i][j], end=' ')
        print()


def senstence_to_words(sentence: str) -> List:
    """
    convert a sentence to a list of words
    the first element in words doesn't contain info about sentence
    (can be optimized)
    """
    words = [None]  # the first element per row doesn't contain any word
    word = ""
    for s in sentence:
        if s != " " and s not in string.punctuation:
            word += s
        else:
            if word != "":
                words.append(word)
            word = ""
    return words


def cfg_to_dict(pcfg):
    cfg_dict = {}
    cfg_data = open("pcfg.txt")
    cfg_lines = cfg_data.readlines()
    for line in cfg_lines:
        line = line.strip()
        if line.startswith("#") or line.startswith("%") or line == "":
            continue
        lhs, rhs = line.split(" -> ")
        if pcfg:
            rule_dict = cfg_dict.get(lhs) if cfg_dict.get(lhs) is not None else {}
            for item in rhs.split(" | "):
                s, p = item.split(" : ")
                rule_dict[s] = p
            cfg_dict[lhs] = rule_dict
        else:
            rhs_list = [item.split(" : ")[0] for item in rhs.split(" | ")]
            if lhs in cfg_dict:
                cfg_dict[lhs].extend(rhs_list)
            else:
                cfg_dict[lhs] = rhs_list
    return cfg_dict


def main():
    cfg_dict = cfg_to_dict(True)
    print(cfg_dict)
    sentence = "I book the flight to Houston."
    words = senstence_to_words(sentence)
    print(words)
    table = pcky(words, cfg_dict)
    print_table(table)


if __name__ == "__main__":
    main()
