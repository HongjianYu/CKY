from typing import Dict, List, Any
import string
def cky(words: List[str], grammar: Dict[str, List]):
    """
    The CKY algorithm finds all possible parses of an ambiguous sentence or phrase generated by a CFG.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar: grammar + lexicon (eg. grammar: NP -> Det N; lexicon: N -> meals)
    """

    # init the 2d table with all elements as {}(empty set), the element type considered
    table = [[{} for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # feed non-terminals into table from terminals in words
        for g in grammar:
            if words[j] in grammar[g]: # find lexicon in grammar
                table[j-1][j].add(g)

        for i in range(j-2, -1, -1):
            for k in range(i+1, j-1):
                b, c = table[i][k], table[k][j]
                bc = str(b + ' ' + c) # eg. "Det N"
                for g in grammar:
                    if bc in grammar[g]:
                        table[i][j].add(g)

    return table



def senstence_to_words(sentence: str) -> List:
    """
    convert a sentence to a list of words
    the first element in words doesn't contain info about sentence
    (can be optimized)
    """
    words = []
    words.append(0) # the first element doesn't contain any word

    word = ""
    for s in sentence:
        if s != ' ' or s not in string.punctuation: word += s
        else:
            if word != "": words.append(word)
            word = ""

    return words


def pcky():
    """
    Ney's variant of the CKY algorithm finds a most probable parse for a phrase or sentence
    in the language generated by an ambiguous Probabilistic Context-Free Grammar.
    """
    pass
