from typing import Dict, List, Tuple
import string
import copy


def cky(words: List[str], grammar: Dict[str, List]):
    """
    The CKY algorithm finds all possible parses of an ambiguous sentence or phrase generated by a CFG.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar eg. NP -> Det N; N -> meals
    """
    # init the 2d table with all elements as {}(empty set), the element type considered
    table = [[set() for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # feed non-terminals into table from terminals in words
        for g in grammar:
            if words[j].lower() in grammar[g]:  # find lexical entries in grammar
                table[j - 1][j].add(g)

        for i in range(j - 2, -1, -1):
            for k in range(i + 1, j):
                for b in table[i][k]:
                    for c in table[k][j]:
                        bc = b + " " + c  # eg. "Det N"
                        for g in grammar:
                            if bc in grammar[g]:
                                table[i][j].add(g)

    return table


def pcky(words: List[str], grammar: Dict[Tuple[str, str], float]):
    """
    Ney's variant of the CKY algorithm finds a most probable parse for a phrase or sentence
    in the language generated by an ambiguous Probabilistic Context-Free Grammar.
    words: the sentence with each word occupies a box in the list of str (starting from index 1)
    grammar eg. NP -> (Det N, 0.2); N -> (meals, 0.3)
    """
    # init the 2d table with all elements as {}(dict), the element type considered
    # each element in the table is a (non-terminal: probability)
    table = [[dict() for j in range(len(words))] for i in range(len(words) - 1)]

    # for building the parsing tree
    back = [[dict() for j in range(len(words))] for i in range(len(words) - 1)]

    for j in range(1, len(words)):

        # init
        for g in grammar:  # g is a tuple of rules or productions, eg. (NP, Det, N) or (N, meals)
            if words[j].lower() == g[1]:
                table[j-1][j][g[0]] = grammar[g]  # probability

        for i in range(j - 2, -1, -1):
            for k in range(i + 1, j):
                for b in table[i][k]:
                    for c in table[k][j]:
                        p_b, p_c = table[i][k][b], table[k][j][c]
                        if p_b > 0 and p_c > 0:
                            for g in grammar:
                                if g[1] == str(b + " " + c):
                                    if table[i][j].get(g[0]) is None or table[i][j].get(g[0]) < grammar[g] * p_b * p_c:
                                        table[i][j][g[0]] = grammar[g] * p_b * p_c
                                        back[i][j][g[0]] = {k, b, c}

    # return table[1][len(words)-1]
    return table


def print_table(table: List[List]):
    for i in range(len(table)):
        for j in range(1, len(table[i])):
            print(table[i][j], end=' ')
        print()


# the parsing tree
class Node:
    def __init__(self, non_terminal, i, j):
        self.non_terminal = non_terminal
        self.pos = (i, j)
        self.children = [] # list of Tuple[left, right]

    def add(self, child):
        self.children.append(child)

    def __str__(self):
        out = f"{self.non_terminal}"
        for i in range(len(self.children)):
            out += f" branch{i + 1}: "
            out += f"{self.children[i][0]}"
            out += f"{self.children[i][1]}"
        return f"[{out}]"

def parse_table(table: List[List], grammar: Dict[str, List]):
    """
    table from cky
    """
    roots = []
    # start symbols (root)
    for s in table[0][len(table[0]) - 1]:
        roots.append(Node(s, 0, len(table[0])-1))
        parsing(roots[-1], table, grammar)

    return roots

def parsing(root: Node, table: List[List], grammar: Dict[str, List]):
    for k in range(root.pos[0]+1, root.pos[1]):
        L = table[root.pos[0]][k]
        R = table[k][root.pos[1]]

        for l in L:
            for r in R:
                if str(l + " " + r) in grammar[root.non_terminal]:
                    root.add((Node(l, root.pos[0], k), Node(r, k, root.pos[1])))
                    parsing(root.children[-1][0], table, grammar)
                    parsing(root.children[-1][1], table, grammar)

def cfg_to_dict(pcfg):
    cfg_dict = {}
    cfg_data = open("grammar.txt")
    cfg_lines = cfg_data.readlines()
    for line in cfg_lines:
        line = line.strip()
        if line.startswith("#") or line.startswith("%") or line == "":
            continue
        lhs, rhs = line.split(" -> ")
        if pcfg:
            rhs = [item.split(" : ") for item in rhs.split(" | ")]
            for item in rhs:
                rule = (lhs, item[0])
                cfg_dict[rule] = float(item[1])
        else:
            rhs_list = [item.split(" : ")[0] for item in rhs.split(" | ")]
            if lhs in cfg_dict:
                cfg_dict[lhs].extend(rhs_list)
            else:
                cfg_dict[lhs] = rhs_list
    return cfg_dict


def senstence_to_words(sentence: str) -> List:
    """
    convert a sentence to a list of words
    the first element in words doesn't contain info about sentence
    (can be optimized)
    """
    words = [None]  # the first element doesn't contain any word
    word = ""
    for s in sentence:
        if s != ' ' and s not in string.punctuation:
            word += s
        else:
            if word != "":
                words.append(word)
            word = ""
    return words


def main():
    use_pcky = False
    cfg_dict = cfg_to_dict(use_pcky)
    print(cfg_dict, end="\n\n")
    sentence = "I book the dinner on the flight to Houston."
    words = senstence_to_words(sentence)
    print(words, end="\n\n")
    if use_pcky:
        table = pcky(words, cfg_dict)
    else:
        table = cky([0, 'b', 'a', 'a', 'b', 'a'], cfg_dict)
    print_table(table)

    roots = parse_table(cky([0, 'b', 'a', 'a', 'b', 'a'], cfg_dict), cfg_dict)
    for root in roots:
        print(root)

if __name__ == "__main__":
    main()
